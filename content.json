{"meta":{"title":"小蜗","subtitle":"小蜗博客","description":"蜗牛没有停歇的时间，他们只能一步一步向上爬，才能到达自己想去的地方。","author":"Jcuser","url":"https://jcuser.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-07-15T09:25:30.000Z","updated":"2019-07-15T12:18:44.516Z","comments":true,"path":"categories/index.html","permalink":"https://jcuser.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-07-15T09:25:30.000Z","updated":"2019-07-15T12:20:58.976Z","comments":true,"path":"about/index.html","permalink":"https://jcuser.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-15T10:23:38.000Z","updated":"2019-07-15T12:19:47.473Z","comments":true,"path":"tags/index.html","permalink":"https://jcuser.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-07-15T12:23:15.660Z","comments":true,"path":"friends/index.html","permalink":"https://jcuser.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机组成原理","slug":"计算机组成原理","date":"2020-05-22T01:32:39.000Z","updated":"2020-05-23T07:26:50.156Z","comments":true,"path":"2020/05/22/计算机组成原理/","link":"","permalink":"https://jcuser.github.io/2020/05/22/计算机组成原理/","excerpt":"","text":"计算机组成原理第1章 ：计算机系统概述1.1 计算机的分类 ​ 电子模拟计算机 特点：数值由连续量来表示，运算过程也是连续的 ​ 电子数字计算机 特点：按位运算，并且不连续地跳动运算 通用计算机： 性能指标从上到下依次递减 超级计算机 ：主要用于科学运算，运算速度每秒万亿次以上，数据存储大，价格贵（天河2号） 大型机 服务器（小型机） PC机 单片机 ：只用一片集成电路做成的计算机，体积小，结构简单，性能指标低，价格便宜 多核机 ：多余一个处理器的计算机芯片 专用计算机： 针对某一任务设计的计算机，一般来说其结构比通用计算机简单。 1.2 计算机的发展简史​ 世界上第一台电子数字计算机是1946年在美国宾夕法利亚大学制成，1800多个电子管，30吨，运算速度5000次每秒。 1.2.1 计算机的五代变化 ​ 第一代：1946—1957年，电子管计算机。 数据处理机开始得到应用。 ​ 第二代：1958—1964年，晶体管计算机。工业控制机开始得到应用。 ​ 第三代：1965—1971年，中小规模集成电路计算机。小型计算机开始出现。 ​ 第四代：1972—1990年，大规模和超大规模集成电路计算机。微型计算机开始出现。 ​ 第五代：1991年开始的巨大规模集成电路计算机。单片机开始出现。 1.2.2 半导体储存器的发展​ 20世纪50—60年代，所有计算机的储存器都是由微小的铁磁体环（磁芯）做成。每个磁芯约1mm。 从1970年开始，半导体储存器经历了11代：单个芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB、和现在的1G （2013年）。其中 1K=2^10、1M=2^20、1G=2^30。 *1.2.3 微处理器的发展 *​ 1971年Intel公司开发出Intel 4004。这是第一个将CPU的所有元件都放入同一块芯片内的产品，于是，微处理器诞生了。 微处理器演变中的另一个主要进步是1972年出现的Intel 8008，这是第一个8位微处理器，它比4004复杂一倍。​ 1974年出现了Intel 8080。这是第一个通用微处理器，而4004和8008是为特殊用途而设计的。8080是为通用微机而设计的中央处理器。 20世纪70年代末才出现强大的通用16位微处理器，8086便是其中之一。 这一发展趋势中的另一阶段是在1981年，贝尔实验室和HP公司开发出了32位单片微处理器。​ Intel于1985年推出了32位微处理器Intel 80386。 到现在的64位处理器和多核处理器。1.2.4 计算机的性能指标 吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量。 响应时间：表征从输入有效到系统产生响应之间的时间度量，用时间单位来表示。 利用率：在给定的时间间隔内系统被实际利用的时间所占的比率，用百分比表示。 处理机字长（机器字长）：指处理机运算器中一次能够完成二进制数运算的位数，如32位、64位。 总线宽度：一般指CPU中运算器与储存器之间进行互连的内部总线二进制位数。 存储器容量：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。 存储器带宽：单位时间内从存储器读出的二进制数信息量，一般用字节/秒表示。 主频/时钟周期：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是MHz（兆赫兹）、GHz（吉赫兹）。 CPU执行时间：表示CPU执行一般程序所占用的CPU时间：$$CPU执行时间 = CPU时钟周期数 × CPU时钟周期（1/f）$$ CPI：表示每条指令周期数，即执行一条指令所需的平均时钟周期数：$$CPI = 执行某段程序所需的CPU时钟周期数 ÷ 程序包含的指令条数$$ MIPS：表示平均每秒执行多少百万条定点指令数：$$MIPS = 指令数 ÷ （程序执行时间 × 10^6）$$ FLOPS：表示每秒执行浮点操作的次数，用来衡量计算机浮点操作的性能：$$FLOPS = 程序中的浮点操作次数 ÷ 程序执行时间（s）$$ 1.3 计算机的硬件","categories":[{"name":"计算机组成原理学习","slug":"计算机组成原理学习","permalink":"https://jcuser.github.io/categories/计算机组成原理学习/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://jcuser.github.io/tags/计算机组成原理/"}],"author":"Jcuser"},{"title":"浅谈计算机网络五层体系结构","slug":"浅谈计算机网络五层体系结构","date":"2019-12-10T12:32:39.000Z","updated":"2019-12-10T14:34:58.858Z","comments":true,"path":"2019/12/10/浅谈计算机网络五层体系结构/","link":"","permalink":"https://jcuser.github.io/2019/12/10/浅谈计算机网络五层体系结构/","excerpt":"","text":"浅谈计算机网络五层体系结构 &nbsp;&nbsp;&nbsp;&nbsp;为了减少网络协议设计的复杂性，网络设计者并不是设计一个单一、巨大的协议来为所有形式的通信规定完整的细节，而是采用把通信问题划分为许多个小问题，然后为每个小问题设计一个单独的协议的方法。&nbsp;&nbsp;&nbsp;&nbsp;这样做使得每个协议的设计、分析、编码和测试都比较容易。分层模型是一种用于开发网络协议的设计方法。本质上，分层模型描述了把通信问题分为几个小问题的方法，每个小问题对应于一层。就像结构化程序设计的思路一样，不可以用一个主函数完成所有功能，而是把所有功能分解之后，用函数实现，然后通过调用的办法形成一个系统。如图1。在这里我主要以一个简单例子来介绍计算机网络的五层体系结构和两台计算机之间的通信。 &nbsp;&nbsp;&nbsp;&nbsp;2016年9月，贵州XX大学与北京中关村软件园签订了校企合作协议，贵州XX大学的学生从2018年开始就可以分批分期到北京中关村软件园去实习。这里的校企合作协议在计算机当中就相当于计算机通信协议(TCP/IP等协议)，简单来说，协议就是计算机之间通过网络实现通信时事先达成的一种“约定”。这种“约定”使那些由不同厂商的设备，不同CPU及不同操作系统组成的计算机之间，只要遵循相同的协议就可以实现通信。&nbsp;&nbsp;&nbsp;&nbsp;协议可以分很多种，每一种协议都明确界定了它的行为规范：两台计算机之间必须能够支持相同的协议，并且遵循相同的协议进行处理，才能实现相互通信。就如学校与中关村软件园如签订的校企合作协议。如果没有这个协议，贵州XX大学的学生是不能被送到北京中关村软件园实习的。&nbsp;&nbsp;&nbsp;&nbsp;下面我将用继续用上面的例子来说明计算机网络体系结构的五层体系结构。 物理层：交通线路&nbsp;&nbsp;&nbsp;&nbsp;去往中关村的路线有很多条，可以选择高速、火车、高铁或者飞机路线，高速又分为很多条路线，每一条路线所花费的时间或者过路费，限速都是不一样的。在计算机网络当中就好比不同的传输介质，有的用双绞线，有的用同轴电缆，再不错的就用光纤了。在相同的时间里，不同的介质传输的速率是不一样的，比如两个人同时从贵阳到北京，一个选择了高速路，一个坐飞机，那么有可能其中一个还在高速堵车时另一个人已经到了北京了。就好像一个相同的数据传输已经接收到了，另一个相同的数据传输还在路上。 数据链路层：交通工具&nbsp;&nbsp;&nbsp;&nbsp;选择好路线后，就是要确定使用什么交通工具了，到达中关村的交通工具多种多样，比如小汽车，大巴车啊还是坐飞机等。这些交通工具在计算机当中就是数据链路层的协议。物理层只负责传输电信号0和1，如果毫无规则，谁也不知道传输的是什么。&nbsp;&nbsp;&nbsp;&nbsp;在计算机网络中，就有这样一些交通工具：以太网协议、ARP协议、MAC地址等。&nbsp;&nbsp;&nbsp;&nbsp;以太网协议规定，一组电信号封装成数据包，我们把这个数据包称为帧。每一个帧由标头和数据两部分构成。由于去中关村实习的学生人数较多，所有要分级分组分批到北京中关村去实习。就好比在以太网协议中，当传输数据很大时，就需要封装成多个帧来传输。&nbsp;&nbsp;&nbsp;&nbsp;标头里存放的就是一些发送者信息，接收者信息。标头长度固定为18字节。但是面临一个问题，学生坐上车之后要去哪里呢？这时就出现了MAC地址，接入网络的每一个计算机都有网卡接口，每个网卡接口都有唯一的地址，称为MAC地址。&nbsp;&nbsp;&nbsp;&nbsp;CSMA协议要求站点在发送数据之前先监听信道。如果信道空闲，站点就可以发送数据；如果信道忙，则站点不能发送数据。就相当于在去北京中关村软件园之前要先问清楚道路是否畅通，万一下雪封路，是不能带学生过去的。&nbsp;&nbsp;&nbsp;&nbsp;“透明传输”是指数据链路层的上一层（网络层）不知道，也不需要知道数据链路层是怎么收发数据的。透明传输的目的是为了不让控制信息和帧数据包 在传输的过程中，不能混乱，所以就要把帧设置为透明，这样一来，数据传输可靠性就增加了。&nbsp;&nbsp;&nbsp;&nbsp;那么问题又来了，学生是如何知道要去实习的地址呢？这时就可以根据协议上的地址来查找了。在计算机网络中就是ARP协议，通过ARP协议我们就可以找到其他计算机的MAC地址了。&nbsp;&nbsp;&nbsp;&nbsp;计算机网络通信中运用CRC校验。在学生输送的过程中，可能会出现学生信息的错误或者有冒名顶替的学生。所以要进行核实，也就是计算机网络当中的差错检验。&nbsp;&nbsp;&nbsp;&nbsp;无论是选择什么交通工具，都会面临三个基本问题：封装成帧、透明传输和差错检测。解决了这三个问题，就可以上路了。 网络层：带队老师&nbsp;&nbsp;&nbsp;&nbsp;确定好了交通工具，目标地点也确定了是北京中关村软件园，但是该怎么走呢？需不需要中转？在哪里中转？这时就需要带队老师作为向导了。而在计算机网络当中，就是IP协议作为数据传输的向导。&nbsp;&nbsp;&nbsp;&nbsp;IP协议有两个版本，IPv4和IPv6。每一台联网的计算机都有一个IP地址，分为网络部分和主机部分。通过网络部分我们可以判断两台计算机是否在同一子网中。但是我们不知道网络部分占几位，所以有了子网掩码(subnet mask)，相当于告诉我们这个IP的网络部分和主机部分各占多少位。&nbsp;&nbsp;&nbsp;&nbsp;通过IP地址和子网掩码判断出两台计算机是否处于同一子网中，如果在同一子网中，就可以通过ARP协议计算MAC地址，发送数据。假如不在同一子网中，则需要网关进行转发传输。&nbsp;&nbsp;&nbsp;&nbsp;当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。&nbsp;&nbsp;&nbsp;&nbsp;DNS服务器。我们在访问某个网站的时候，一般都是通过域名来访问的而不是直接输入IP地址，这时DNS服务器就可以将域名解析返回对应的IP给我们。&nbsp;&nbsp;&nbsp;&nbsp;通过这些协议，需不需要中转，在哪里中转，是否成功都可以很清楚了。 传输层：培训机构指挥调度&nbsp;&nbsp;&nbsp;&nbsp;学生到达中关村软件园后，因为学生较多，所以培训机构需要进行分配。学生到达后，培训机构要安排学生到指定的地方去面试。而且在接收学生的过程中，中关村软件园不只是签订了贵州XX大学一间的学生，还有很多来自其他地方的学生，所有培训机构的调度人员要控制来实习的学生人数，避免人数太多导致无法分配实习岗位。学生无法正常进入实习岗位。&nbsp;&nbsp;&nbsp;&nbsp;在计算机网络传输层中，调度者有两个，分别是TCP和UDP。&nbsp;&nbsp;&nbsp;&nbsp;TCP很严格，一个数据包都不能丢，是负责任的调度者，相当于去中关村实习的学生每一个都要被安排到实习岗位，而且是按顺序一个一个安排如果没有的话就再安排面试，直到进入实习岗位。但是UDP就是个不负责的调度人员了，不管送去的学生(数据包)有没有进入实习岗位，都会继续安排其他学生面试。不管前面的学生有没有进入实习岗位，反正安排给你一次面试的就行了。&nbsp;&nbsp;&nbsp;&nbsp;TCP调度者主要负责三大内容，分别为可靠性传输，流量控制和拥塞避免。可靠性传输就是在传输过程中当有数据包丢失时重新发送。流量控制就是建了个缓冲池，让接收方和发送方用合适的速率传输，不会因为传输太快导致数据丢失。比如在向中关村输送学生的过程中，中关村软件园还有很多送去的学生没有进入实习岗位，那么就叫后面还没去的学生先等一等再去，避免去了没有地方居住。UDP 调度者因为不需要严格的建立连接，又不需要各种确认机制保证包不乱，所以整个协议非常轻量。如果在网络好的情况下，UDP可以做到快且正确率高。 应用层：学生及简历&nbsp;&nbsp;&nbsp;&nbsp;学生到达中关村后需要介绍自己，那就需要简历和介绍信，不然你到中关村软件园后别人也不清楚你适合在哪个岗位实习。学生的心中只有目的地，签订了实习协议，中间的路怎么走，用什么交通工具，就交给底层的协议了。在计算机网络中，应用层协议就是要在数据到达目的地后，能够把自己介绍清楚。在应用层协议中，常见的有DNS协议和HTTP协议。&nbsp;&nbsp;&nbsp;&nbsp;DNS协议，用来把域名解析为IP。DNS协议是为了方便我们记住目标主机IP，世界上有数不清的网址，如果我们都用记IP的话，是很不好记的，所以用DNS协议，将IP用容易记的单词来代替，DNS协议将域名解析到对应的IP即可。当我们更换服务器的时候，IP地址也会改变，那么如果是记的IP，将无法访问原来的内容。用域名代替后，即使服务器IP换了，再用DNS协议将域名解析到新的服务器IP后客户端依然可以使用原来的域名来访问原来的内容。&nbsp;&nbsp;&nbsp;&nbsp;HTTP协议，我们接触得最多。在万维网(WWW)中，HTTP协议带着文本，图像，音频等数据，往来于不同的站点，就像学生身上带着介绍信，去向中关村后要拿出自己的介绍信，别人才知道你是谁，你的目的是什么。&nbsp;&nbsp;&nbsp;&nbsp;DHCP协议采用客户端/服务器模型，主机地址的动态分配任务由网络主机驱动。当DHCP服务器接收到来自网络主机申请地址的信息时，才会向网络主机发送相关的地址配置等信息，以实现网络主机地址信息的动态配置。好比培训机构收到学生后，为学生分配好宿舍和安排面试，然后告诉学校这些学生已经安排好了，给学校一个反馈。 参考文献： 《计算机网络》第七版 电子工业出版社 谢希仁","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jcuser.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jcuser.github.io/tags/计算机网络/"}],"author":"Jcuser"},{"title":"HTML5+CSS3笔记","slug":"H5+C3","date":"2019-11-11T11:32:39.000Z","updated":"2019-11-12T14:11:39.459Z","comments":true,"path":"2019/11/11/H5+C3/","link":"","permalink":"https://jcuser.github.io/2019/11/11/H5+C3/","excerpt":"","text":"emmet语法？ H5IE 9 + H5新增的语义化标签除了ie，这些标签默认是块元素 header ：定义页面头部 nav：导航栏标签 article：内容标签 sectiom：文档标签 aside：侧边栏标签 footer：尾部标签 H5新增的多媒体标签使用这些标签前前查文档（谷歌默认不自动播放，但有解决方案） video:视频标签 audio：音频标签 H5新增的input类型 type属性值 说明 emali 限制用户必须输入Email类型 url 限制用户必须输入URL类型 date 限制用户必须输入日期类型 time 限制用户必须输入时间类型 month 限制用户必须输入月类型 week 限制用户必须输入周类型 number 限制用户必须输入数字类型 search 搜索框 color 颜色选择表单 H5新增的input属性 属性 值 说明 required required 表示必填 placeholder 提示文本 提示文本 autofocus autofocus 页面加载完自动聚焦 autocomplete off/on 是否保存记录，只有拥有name属性并且提交成功的数据才会被保存，默认已经打开 multiple multiple 可选择多文件提交 C3新增选择器属性选择器 选择器[属性名]{ } /*例子：*/ input[value]{ /*表示所有拥有value属性的input*/ } input[name=\"123\"]{ /*表示所有name属性值是123的input*/ } 选择器 描述 [attribute] 用于选取带有指定属性的元素。 [attribute=value] 用于选取带有指定属性和值的元素。 [attribute~=value] 用于选取属性值中包含指定词汇的元素。 [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [[attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 结构伪类选择器 选择器 功能描述 版本 E:last-child 选择父元素的倒数第一个子元素E，相当于E:nth-last-child(1) 3 E:nth-child(n) 选择父元素的第n个子元素，n从1开始计算 3 E:nth-last-child(n) 选择父元素的倒数第n个子元素，n从1开始计算 3 E:first-of-type 选择父元素下同种标签的第一个元素，相当于E:nth-of-type(1) 3 E:last-of-type 选择父元素下同种标签的倒数第一个元素，相当于E:nth-last-of-type(1) 3 E:nth-of-type(n) 与:nth-child(n)作用类似，用作选择使用同种标签的第n个元素 3 E:nth-last-of-type 与:nth-last-child作用类似，用作选择同种标签的倒数第一个元素 3 E:only-child 选择父元素下仅有的一个子元素，相当于E:first-child:last-child或E:nth-child(1):nth-last-child(1) 3 E:root 选择文档的根元素，对于HTML文档，根元素永远HTML 3 E:empty 选择空节点，即没有子元素的元素，而且该元素也不包含任何文本节点 3 E:only-of-type 选择父元素下使用同种标签的唯一子元素，相当于E:first-of-type:last-of-type或E:nth-of-type(1):nth-last-of-type(1) 3 伪元素选择器 ::first-letter 第一个字 ::first-line 第一行（以浏览器为准的第一行） ::selection 被选中的字行（鼠标选中的字段）只能向 ::selection 选择器应用少量 CSS 属性：color、background、cursor 以及 outline。 ::before 和 ::after 必须带一个属性content 2.在内部内容的前面或者后面插入内容 &lt;div&gt;必须带一个属性content&lt;/div&gt; div::before { content: &quot;我是插入的内容&quot;; background: #572eb8; } 3.当插入的内容定义宽高和其他属性时，其实就是一个盒子（必须通过display转换，因为默认是一个行内元素）。 &lt;body&gt; &lt;div&gt;盒子1&lt;/div&gt; &lt;/body&gt; div{ width: 500px; height: 500px; border: 1px solid #000; } div::before{ content: &quot;插入的盒子&quot;; display: block; width: 200px; height: 200px; background: rgb(211, 29, 29); } 4.上述可以解释清除浮动的后面两种方法，单伪元素法和双伪元素法（清除浮动的四种方法：额外标签法，overflow：hidden，单伪元素法和双伪元素法） C3盒子模型box-sizing 该属性有两个值content-box/border-box content-box：默认的，盒子的大小计算公式：width + padding + border border-box：盒子大小不会随着margin和border的大小而扩大（前提是padding + border &lt;= width） css3其他新特性图片模糊 filter：函数（）； calc函数 该函数可以帮你执行一些计算 例子 width:calc(100%-100px); C3 过渡transition:要过渡的属性 过渡时间 运动曲线 何时开始[,要过渡的属性 过渡时间 运动曲线 何时开始[,...]]; 要过渡的属性 : 想要变化的css属性（可以省略，默认是all） 过渡时间： 单位是s，例如0.5s 运动曲线：默认是 ease （可以省略） ease ：逐渐变慢 linear：匀速 ease-in：加速 ease-out：减速 ease-in-out：慢》块》慢 何时开始：单位是秒，默认是0s（可以省略） 2D转换transform（可以实现元素的位移、旋转、缩放等） 移动：translate对行元素无效 translate(x,y):xy两个方向都可以移动 translateX(n)：只移动x方向 translateY(n)：只移动y方向 语法： div{ transform:translate(20px,100px)/*水平移动20px 垂直移动100px，如果值是百分比，那么是相对于盒子的对应方向方向上的长度*/ } 旋转：rotale度数单位是deg，如果度数是正数则顺时针旋转，度数是负数则逆时针旋转，旋转点默认是元素的中心 语法： div{ transform:rotate(度数); } 设置旋转中心：transform-origin x y默认都是50%，这里的%是相对于元素高宽，还可以使用方位名词（top bottom left right center） 例如 top left 表示左上角 div{ transform-origin: x y; /*transform-origin: top left;*/ } 缩放：scale可以按元素本身的大小按倍数放大，放大1倍为不变，可以是小数 语法： div{ trabsform:scale(x,y); } trabsform:scale(1,1):放大了一倍，等于没变 trabsform:scale(2,2)：高宽都放大两边 trabsform:scale(2)：相对于trabsform:scale(2,2) trabsform:scale(0.5,0.5)：缩小 2D转换综合语法直接在后面跟空格就可以添加了，对顺序没有硬性要求，但切记移动移动要在旋转之前，不然会出现你意想不到的效果（移动是按相对于元素的方向移动的，当你先旋转元素之后，元素的方向会与屏幕的方向不一样） div{ trabsform:translate(x,y) rotate(度数) scale(x,y) } C3 动画相对于过渡，动画可以实现更多变化，控制，连续播放等效果 制作动画分两步： 定义动画 使用（调用）动画 定义动画语法：(中间可以定义如何时间点的样式) @keyframes 动画名{ 0%{ width:100px; } 41%{ rotate(45deg) } 100%{ width:200px; } } 使用动画语法： div{ animation:动画名; animation-duration:持续时间; } 动画常见属性 属性 描述 @keyframes 定义动画 animation 所有动画的简写，除啦animation-play-state属性 animation-name 调用的动画的名称（必须的） animation-duration 动画的持续时间 animation-timing-function 动画的速度曲线，默认是“ease”，这里相对于过渡增加了步长steps(n),表示动画分为n步执行 animation-delay 动画开始时间，默认是0 animation-iteration-count 动画执行次数，默认是1，还有infinite animation-direction 动画下一周期是否逆向播放，默认是“normal”，还有”alternate“（逆播放） animation-play-state 动画是否运行，默认是“running”，还有“paused” animation-fill-mode 动画结束状态，保持结束状态：forwards，回到起始状态：backwards 动画属性简写语法： 前两个属性是必须的 div{ animation:动画名称 持续时间 运动曲线 开始时间 播放次数 是否下一周期反向 动画结束的状态; } 阴影 ：box-shadow语法： div{ box-shadow:x偏移 y偏移 模糊距离 阴影大小 颜色 模糊位置; } x偏移：（必需） y偏移：（必需） 模糊距离：（可选） 阴影大小（可选） 颜色：（可选） 模糊位置：默认（inset）外部阴影，outset改为内阴影（可选） 3D转换移动：translate3d transform:translateX(100px):仅仅在x轴上移动； transform:translateY(100px):仅仅在y轴上移动； transform:translateZ(100px):仅仅在z轴上移动； transform:translate3d(x,y,z):x,y,z三个方向移动； 透视：perspective代码给上级，会让下级有透视效果 perspective:500:表示虚拟距离，既当元素向前移动500px时会占满屏幕 旋转：rotate3d transform:rotateX(100deg):仅仅沿着x轴旋转； transform:rotateY(100deg):仅仅沿着y轴旋转； transform:rotateZ(100deg):仅仅沿着z轴旋转； transform:rotate3d(x,y,z,deg):沿着x,y,z轴旋转,单位为deg(沿着x,y,z的矢量轴旋转)； 3D呈现：transform-style当一个元素没有开启3D呈现时，如果对这个元素的父元素进行3D旋转时，该元素会转变为2D。 代码给父（或父以上）级，但影响的是子元素，就像 perspective一样。 transform-style:flat;子元素不开启3D呈现，默认的 transform-style:preserve-3d;子元素开启3D立体空间 浏览器私有前缀 -moz-：firefox -ms-：ie -webkit-：chrome，Safari -o-：Opera C3渐变色C3中有线性渐变和径向渐变两种渐变 CSS background-image 属性 url(‘URL’) 图像的URL none 无图像背景会显示。这是默认 linear-gradient() 创建一个线性渐变的 “图像”(从上到下) radial-gradient() 用径向渐变创建 “图像”。 (center to edges) repeating-linear-gradient() 创建重复的线性渐变 “图像”。 repeating-radial-gradient() 创建重复的径向渐变 “图像” inherit 指定背景图像应该从父元素继承 线性渐变线性渐变是指颜色的渐变方向是沿着一个方法变换的 语法： background-image: linear-gradient(direction, color-stop1, color-stop2, ...); direction：渐变方向 可以是方位名词： to bottom、to top、to right、to left、to bottom right，等等 可以是角度： color-stop：渐变颜色，至少两个值； 重复线性渐变径向渐变有一个点向周围方向扩散 上菜鸟教程吧 CSS背景图片大小：background-size background-size:50px 100px;(高50宽100) background-size:cover;(等比例缩放到高宽都足以填充元素) background-size:contain;(等比例缩放到高或宽足以填充元素)","categories":[{"name":"HTML","slug":"HTML","permalink":"https://jcuser.github.io/categories/HTML/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://jcuser.github.io/tags/html5/"},{"name":"css3","slug":"css3","permalink":"https://jcuser.github.io/tags/css3/"}],"author":"Jcuser"},{"title":"JAVA程序设计-JDK安装及环境配置","slug":"JAVA程序设计-JDK安装及环境配置","date":"2019-08-29T11:32:39.000Z","updated":"2019-08-30T01:29:37.829Z","comments":true,"path":"2019/08/29/JAVA程序设计-JDK安装及环境配置/","link":"","permalink":"https://jcuser.github.io/2019/08/29/JAVA程序设计-JDK安装及环境配置/","excerpt":"","text":"JDK的安装下载打开JDK下载 找到要下载的版本和对应的操作系统，点击下载 安装（傻瓜式） 安装目录可自定义 Win系统下JAVA环境变量的配置 安装好JDK后我们还需要配置环境变量 单击Win按键，也就是打开左下角菜单，输入高级设置，会出现查看系统高级设置，点击进去。也可以打开计算机，右键选择属性，然后系统高级设置 点击环境变量，在系统变量下新建变量JAVA_HOME，变量值为JDK安装路径。再新建CLASSPATH变量，变量值为.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tool.jar注意前面有一点 在path中添加环境变量 将%JAVA_HOME%\\bin和%CLASSPATH%变量添加到path中 检验是否安装成功 打开cmd，输入java，显示详细信息，输入javac，显示详细信息则表示配置成功","categories":[{"name":"JAVA程序设计","slug":"JAVA程序设计","permalink":"https://jcuser.github.io/categories/JAVA程序设计/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://jcuser.github.io/tags/面向对象/"},{"name":"JAVA学习","slug":"JAVA学习","permalink":"https://jcuser.github.io/tags/JAVA学习/"},{"name":"JDK安装","slug":"JDK安装","permalink":"https://jcuser.github.io/tags/JDK安装/"}],"author":"Jcuser"},{"title":"JavaScript监听事件","slug":"JavaScript监听事件","date":"2019-07-16T01:32:39.000Z","updated":"2019-07-16T02:39:14.425Z","comments":true,"path":"2019/07/16/JavaScript监听事件/","link":"","permalink":"https://jcuser.github.io/2019/07/16/JavaScript监听事件/","excerpt":"","text":"事件的概念：JavaScript使我们有能力创建动态页面，网页中的每一个元素都可以产生某些触发JavaScript函数的事件。我们可以认为事件是可以被JavaScript侦测到的一种行为。 事件流：事件流主要分为冒泡型事件和捕获型事件。IE浏览器目前只支持冒泡型事件，而支持标准DOM的浏览器比如火狐、Chrome等两者都支持。 使用返回值改变HTML元素的默认行为：HTML元素大都包含了自己的默认行为，例如：超链接、提交按钮等。我们可以通过在绑定事件中加上”return false”来阻止它的默认行为。 通用性的事件监听方法： 绑定HTML元素属性： &lt;input type=&quot;button&quot; value=&quot;clickMe&quot; onclick=&quot;check(this)&quot;&gt; 绑定DOM对象属性： document.getElementById(&quot;xxx&quot;).onclick=test; &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>JavaScript两种通用性的绑定事件的方式&lt;/title> &lt;script type=\"text/javascript\"> function test1(){ alert(\"绑定HTML元素属性\"); } function test2(){ alert(\"绑定DOM对象属性\"); } &lt;/script> &lt;/head> &lt;body> &lt;a href=\"https://www.baidu.com\" onclick=\"return false\">百度&lt;/a> &lt;!--超链接有自己的默认行为，即当点击的时候会跳转页面。若是要把默认行为给去掉，可以绑定一个onclick事件， onclick=\"return false\"。这样点击就不会跳转页面了。--> &lt;input type=\"button\" id=\"test1\" value=\"测试1\" onclick=\"test1()\"> &lt;button type=\"button\" id=\"test2\">&lt;b>测试2&lt;/b>&lt;/button> &lt;script type=\"text/javascript\"> document.getElementById(\"test2\").onclick=test2;//此处不能加括号，加了括号表示调用函数。 /*注意：函数需要通过后面的触发才会调用执行，而上面这句没有放在函数里面，JavaScript从上往下解析的时候，解析到上面的那句代码， 若还没有解析到&lt;body>中的id--test2,就会报错。故JavaScript代码要放在后面。*/ &lt;/script> &lt;/body> &lt;/html>","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://jcuser.github.io/categories/前端学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jcuser.github.io/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"https://jcuser.github.io/tags/前端/"}],"author":"Jcuser"}]}