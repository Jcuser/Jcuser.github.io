{"meta":{"title":"小蜗","subtitle":"小蜗博客","description":"蜗牛没有停歇的时间，他们只能一步一步向上爬，才能到达自己想去的地方。","author":"Jcuser","url":"https://jcuser.github.io","root":"/"},"pages":[{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2019-07-15T12:23:15.660Z","comments":true,"path":"friends/index.html","permalink":"https://jcuser.github.io/friends/index.html","excerpt":"","text":""},{"title":"about","date":"2019-07-15T09:25:30.000Z","updated":"2019-07-15T12:20:58.976Z","comments":true,"path":"about/index.html","permalink":"https://jcuser.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-15T09:25:30.000Z","updated":"2019-07-15T12:18:44.516Z","comments":true,"path":"categories/index.html","permalink":"https://jcuser.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-15T10:23:38.000Z","updated":"2019-07-15T12:19:47.473Z","comments":true,"path":"tags/index.html","permalink":"https://jcuser.github.io/tags/index.html","excerpt":"","text":""},{"title":"Java序列化实践","date":"2020-09-04T09:32:39.000Z","updated":"2022-01-24T15:24:09.752Z","comments":true,"path":"征文比赛/index.html","permalink":"https://jcuser.github.io/征文比赛/index.html","excerpt":"","text":"1.什么是java序列化和反序列化序列化：将java对象转换为字节序列 反序列化：将字节序列转换为java对象 为什么要做序列化：序列化对象，可以使得对象可以保存在磁盘中或者可以通过网络进行传输，对象不必依赖程序而存在，反序列化对象可以将字节序列转换成原来的对象。 2.序列化方式实现 Serializable接口 如果你想要将对象保存到文件中或者通过网络传输，那么该对象的类就要实现Serializable接口 实践： 创建一个java类Student：实现了Serializable接口, public class Student implements Serializable { private String name; private int age; //省略getter setter 构造函数 //...... } 创建一个main方法，在main方法中测试。 首先创建一个Student的实例，创建ObjectOutputStream输出流，然后调用ObjectOutputStream的writeObject()方法将studen对象序列化到test.txt文件中。 public static void main(String[] args) { try { Student student = new Student(\"张三\",18); //创建一个输对象出流 ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"test.txt\")); outputStream.writeObject(student); } catch (IOException e) { e.printStackTrace(); } } 执行，在src文件夹下生成了test.txt文件，我们打开看看 中文乱码了，查看文件编码为ANSI编码。我们先不管，再反序列化一下看看能不能反序列化回来。 ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"test.txt\")); Student student2 = (Student) inputStream.readObject(); System.out.println(\"反序列化：\"+student2); 从结果可以看出是可以序列化是成功了。 有一点注意的是，反序列化时不会调用构造方法。 属性为引用数据类型的对象，如果要序列化，那么该属性也要实现Serializable接口才能实现该对象的完全序列化，否则就会报错NotSerializableException 新增一个Class(班级)类： public class Class { private String className; private int nums; } Student新增Calss属性 public class Student implements Serializable { private String name; private int age; private Class aClass; Class实现Serializable接口，调用序列化和反序列化 java序列化算法 所有保存到磁盘的对象都有一个序列化编号 当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。 如果此对象已经序列化过，则直接输出编号即可。 序列化存在的问题 由于序列化时不会重复序列化同一个对象，所以对象第一次被序列化之后，后面对对象进行了修改再次序列化时得到的 还是原来的序列化对象。 public static void main(String[] args) { try { String name=new String(\"sss\"); Class aClass = new Class(\"1班\",40); Student student = new Student(\"张三\",18,aClass); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"test.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"test.txt\")); outputStream.writeObject(student); Student student1 = (Student) inputStream.readObject(); System.out.println(\"反序列化：\"+student1); aClass.setClassName(\"2班\"); student.setaClass(aClass); outputStream.writeObject(student); Student student2 = (Student) inputStream.readObject(); System.out.println(\"反序列化：\"+student2); } catch (Exception e) { e.printStackTrace(); } } 输出结果： 可以看出我修改后再序列化，反序列化回来的对象还是和第一次一样。 transient关键字 如果我们希望有些类的成员不被序列化，可以使用transient关键字修饰。 public class Student implements Serializable { private transient String name; private int age; private Class aClass; } 输出结果： 反序列化：Student{name=’null’, age=18, aClass=Class{className=’1班’, nums=40}} 使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。 此外，你可以通过重新writeObject()和readObject()方法实现自己的序列化方法。 序列化版本号serialVersionUID 随着项目的升级，java序列化的class文件会改变，那么序列化怎么保证前后兼容性呢？java序列化提供了一个private static final long serialVersionUID 的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。 我们先给Student一个序列化版本号，然后把Student序列化保存到stu.txt文件中。 public class Student implements Serializable { private transient String name; private int age; private Class aClass; } 然后修改，把age的类型改成long; public class Student implements Serializable { private static final long serialVersionUID = 1001L; private transient String name; private long age; private Class aClass; } 输出结果： java.io.InvalidClassException: 更文挑战.day01.serializable.Student; local class incompatible: stream classdesc serialVersionUID = 8678683859078700039, local class serialVersionUID = -3533377131204334585 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431) at 更文挑战.day01.serializable.Main.main(Main.java:23) Student加上序列号版本号 输出结果： 反序列化：Student{name=’null’, age=18, aClass=Class{className=’1班’, nums=40}} 虽然我改变了类，但是因为我定义的序列号版本号相同，所以还是反序列化成功，由于我比较好奇如果类型不兼容会怎样，于是我定义了序列化版本号，先序列化保存到文件，修改Student类的age类型为String。 输出反序列化结果： java.io.InvalidClassException: 更文挑战.day01.serializable.Student; incompatible types for field age at java.io.ObjectStreamClass.matchFields(ObjectStreamClass.java:2453) at java.io.ObjectStreamClass.getReflector(ObjectStreamClass.java:2347) at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:753) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431) at 更文挑战.day01.serializable.Main.main(Main.java:23) 类型不兼容，反序列化失败。 总结 需要网络传输的对象的类需要实现Serializable接口。 对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。 使用transient修饰变量不会被序列化。 序列化对象的引用类型成员变量，也必须是可序列化的，不然会报错。 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。 建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。","author":"Jcuser"}],"posts":[{"title":"Java序列化实践","slug":"java序列化实践","date":"2022-01-25T09:32:39.000Z","updated":"2022-01-25T01:32:37.090Z","comments":true,"path":"2022/01/25/java序列化实践/","link":"","permalink":"https://jcuser.github.io/2022/01/25/java序列化实践/","excerpt":"","text":"1.什么是java序列化和反序列化序列化：将java对象转换为字节序列 反序列化：将字节序列转换为java对象 为什么要做序列化：序列化对象，可以使得对象可以保存在磁盘中或者可以通过网络进行传输，对象不必依赖程序而存在，反序列化对象可以将字节序列转换成原来的对象。 2.序列化方式实现 Serializable接口 如果你想要将对象保存到文件中或者通过网络传输，那么该对象的类就要实现Serializable接口 实践： 创建一个java类Student：实现了Serializable接口, public class Student implements Serializable { private String name; private int age; //省略getter setter 构造函数 //...... } 创建一个main方法，在main方法中测试。 首先创建一个Student的实例，创建ObjectOutputStream输出流，然后调用ObjectOutputStream的writeObject()方法将studen对象序列化到test.txt文件中。 public static void main(String[] args) { try { Student student = new Student(\"张三\",18); //创建一个输对象出流 ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"test.txt\")); outputStream.writeObject(student); } catch (IOException e) { e.printStackTrace(); } } 执行，在src文件夹下生成了test.txt文件，我们打开看看 中文乱码了，查看文件编码为ANSI编码。我们先不管，再反序列化一下看看能不能反序列化回来。 ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"test.txt\")); Student student2 = (Student) inputStream.readObject(); System.out.println(\"反序列化：\"+student2); 从结果可以看出是可以序列化是成功了。 有一点注意的是，反序列化时不会调用构造方法。 属性为引用数据类型的对象，如果要序列化，那么该属性也要实现Serializable接口才能实现该对象的完全序列化，否则就会报错NotSerializableException 新增一个Class(班级)类： public class Class { private String className; private int nums; } Student新增Calss属性 public class Student implements Serializable { private String name; private int age; private Class aClass; Class实现Serializable接口，调用序列化和反序列化 java序列化算法 所有保存到磁盘的对象都有一个序列化编号 当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。 如果此对象已经序列化过，则直接输出编号即可。 序列化存在的问题 由于序列化时不会重复序列化同一个对象，所以对象第一次被序列化之后，后面对对象进行了修改再次序列化时得到的 还是原来的序列化对象。 public static void main(String[] args) { try { String name=new String(\"sss\"); Class aClass = new Class(\"1班\",40); Student student = new Student(\"张三\",18,aClass); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"test.txt\")); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"test.txt\")); outputStream.writeObject(student); Student student1 = (Student) inputStream.readObject(); System.out.println(\"反序列化：\"+student1); aClass.setClassName(\"2班\"); student.setaClass(aClass); outputStream.writeObject(student); Student student2 = (Student) inputStream.readObject(); System.out.println(\"反序列化：\"+student2); } catch (Exception e) { e.printStackTrace(); } } 输出结果： 可以看出我修改后再序列化，反序列化回来的对象还是和第一次一样。 transient关键字 如果我们希望有些类的成员不被序列化，可以使用transient关键字修饰。 public class Student implements Serializable { private transient String name; private int age; private Class aClass; } 输出结果： 反序列化：Student{name=’null’, age=18, aClass=Class{className=’1班’, nums=40}} 使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。 此外，你可以通过重新writeObject()和readObject()方法实现自己的序列化方法。 序列化版本号serialVersionUID 随着项目的升级，java序列化的class文件会改变，那么序列化怎么保证前后兼容性呢？java序列化提供了一个private static final long serialVersionUID 的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。 我们先给Student一个序列化版本号，然后把Student序列化保存到stu.txt文件中。 public class Student implements Serializable { private transient String name; private int age; private Class aClass; } 然后修改，把age的类型改成long; public class Student implements Serializable { private static final long serialVersionUID = 1001L; private transient String name; private long age; private Class aClass; } 输出结果： java.io.InvalidClassException: 更文挑战.day01.serializable.Student; local class incompatible: stream classdesc serialVersionUID = 8678683859078700039, local class serialVersionUID = -3533377131204334585 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431) at 更文挑战.day01.serializable.Main.main(Main.java:23) Student加上序列号版本号 输出结果： 反序列化：Student{name=’null’, age=18, aClass=Class{className=’1班’, nums=40}} 虽然我改变了类，但是因为我定义的序列号版本号相同，所以还是反序列化成功，由于我比较好奇如果类型不兼容会怎样，于是我定义了序列化版本号，先序列化保存到文件，修改Student类的age类型为String。 输出反序列化结果： java.io.InvalidClassException: 更文挑战.day01.serializable.Student; incompatible types for field age at java.io.ObjectStreamClass.matchFields(ObjectStreamClass.java:2453) at java.io.ObjectStreamClass.getReflector(ObjectStreamClass.java:2347) at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:753) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431) at 更文挑战.day01.serializable.Main.main(Main.java:23) 类型不兼容，反序列化失败。 总结 需要网络传输的对象的类需要实现Serializable接口。 对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。 使用transient修饰变量不会被序列化。 序列化对象的引用类型成员变量，也必须是可序列化的，不然会报错。 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。 建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://jcuser.github.io/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://jcuser.github.io/tags/java/"}],"author":"Jcuser"},{"title":"Vmware虚拟机三种网络连接方式详解","slug":"vmware虚拟机三种网络连接","date":"2020-09-04T01:32:39.000Z","updated":"2022-01-24T02:19:59.859Z","comments":true,"path":"2020/09/04/vmware虚拟机三种网络连接/","link":"","permalink":"https://jcuser.github.io/2020/09/04/vmware虚拟机三种网络连接/","excerpt":"","text":"Vmware虚拟机三种网络连接方式详解​ Vmware为我们提供了三种网络工作模式，它们分别是：Bridged（桥接模式）、NAT（网络地址转换模式）、Host-Only（仅主机模式）。 一、Bridged（桥接模式）将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。其网络结构如下图所示： 具体操作如下： 1、首先，安装完系统之后，在开启系统之前，点击“编辑虚拟机设置”来设置网卡模式。 2、 打开虚拟网络编辑器 3、 选择VMnet0，选择桥接模式，桥接到本机可用的网络上（打开网络适配器可以查看） 4、检验是否成功 在虚拟机输入 ip addr 命令 inet后的就是虚拟机网络ip地址 本地主机ping虚拟机ip： 网络连接成功。 二、NAT（网络地址转换模式）如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。其网络结构如下图所示： 具体操作如下： 1、打开虚拟机网络编辑器，编辑VMnet8设置NAT模式 2、编辑虚拟机网络适配器，选择NAT模式 3、测试 开启虚拟机，输入ip addr命令，查看ip 打开Xshell远程连接测试 成功！ 这就是NAT模式，利用虚拟的NAT设备以及虚拟DHCP服务器来使虚拟机连接外网，而VMware Network Adapter VMnet8虚拟网卡是用来与虚拟机通信的。 三、Host-Only（仅主机模式）Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。其网络结构如下图所示： 1、打开虚拟网络编辑器，这种VMnet1为仅主机模式 2、设置虚拟机网络适配器为仅主机模式 3、开启虚拟机测试 输入命令：ip addr 获取到ip但是不能访问外网 测试Xshell连接： 连接成功！","categories":[{"name":"Vmware虚拟机","slug":"Vmware虚拟机","permalink":"https://jcuser.github.io/categories/Vmware虚拟机/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://jcuser.github.io/tags/操作系统/"},{"name":"Vmware","slug":"Vmware","permalink":"https://jcuser.github.io/tags/Vmware/"}],"author":"Jcuser"},{"title":"JAVA程序设计-JDK安装及环境配置","slug":"JAVA程序设计-JDK安装及环境配置","date":"2019-08-29T11:32:39.000Z","updated":"2022-01-24T02:20:01.129Z","comments":true,"path":"2019/08/29/JAVA程序设计-JDK安装及环境配置/","link":"","permalink":"https://jcuser.github.io/2019/08/29/JAVA程序设计-JDK安装及环境配置/","excerpt":"","text":"JDK的安装下载打开JDK下载 找到要下载的版本和对应的操作系统，点击下载 安装（傻瓜式） 安装目录可自定义 Win系统下JAVA环境变量的配置 安装好JDK后我们还需要配置环境变量 单击Win按键，也就是打开左下角菜单，输入高级设置，会出现查看系统高级设置，点击进去。也可以打开计算机，右键选择属性，然后系统高级设置 点击环境变量，在系统变量下新建变量JAVA_HOME，变量值为JDK安装路径。再新建CLASSPATH变量，变量值为.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tool.jar注意前面有一点 在path中添加环境变量 将%JAVA_HOME%\\bin和%CLASSPATH%变量添加到path中 检验是否安装成功 打开cmd，输入java，显示详细信息，输入javac，显示详细信息则表示配置成功","categories":[{"name":"JAVA程序设计","slug":"JAVA程序设计","permalink":"https://jcuser.github.io/categories/JAVA程序设计/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://jcuser.github.io/tags/面向对象/"},{"name":"JAVA学习","slug":"JAVA学习","permalink":"https://jcuser.github.io/tags/JAVA学习/"},{"name":"JDK安装","slug":"JDK安装","permalink":"https://jcuser.github.io/tags/JDK安装/"}],"author":"Jcuser"},{"title":"JavaScript监听事件","slug":"JavaScript监听事件","date":"2019-07-16T01:32:39.000Z","updated":"2022-01-24T02:19:28.735Z","comments":true,"path":"2019/07/16/JavaScript监听事件/","link":"","permalink":"https://jcuser.github.io/2019/07/16/JavaScript监听事件/","excerpt":"","text":"事件的概念：JavaScript使我们有能力创建动态页面，网页中的每一个元素都可以产生某些触发JavaScript函数的事件。我们可以认为事件是可以被JavaScript侦测到的一种行为。 事件流：事件流主要分为冒泡型事件和捕获型事件。IE浏览器目前只支持冒泡型事件，而支持标准DOM的浏览器比如火狐、Chrome等两者都支持。 使用返回值改变HTML元素的默认行为：HTML元素大都包含了自己的默认行为，例如：超链接、提交按钮等。我们可以通过在绑定事件中加上”return false”来阻止它的默认行为。 通用性的事件监听方法： 绑定HTML元素属性： &lt;input type=&quot;button&quot; value=&quot;clickMe&quot; onclick=&quot;check(this)&quot;&gt; 绑定DOM对象属性： document.getElementById(&quot;xxx&quot;).onclick=test; &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>JavaScript两种通用性的绑定事件的方式&lt;/title> &lt;script type=\"text/javascript\"> function test1(){ alert(\"绑定HTML元素属性\"); } function test2(){ alert(\"绑定DOM对象属性\"); } &lt;/script> &lt;/head> &lt;body> &lt;a href=\"https://www.baidu.com\" onclick=\"return false\">百度&lt;/a> &lt;!--超链接有自己的默认行为，即当点击的时候会跳转页面。若是要把默认行为给去掉，可以绑定一个onclick事件， onclick=\"return false\"。这样点击就不会跳转页面了。--> &lt;input type=\"button\" id=\"test1\" value=\"测试1\" onclick=\"test1()\"> &lt;button type=\"button\" id=\"test2\">&lt;b>测试2&lt;/b>&lt;/button> &lt;script type=\"text/javascript\"> document.getElementById(\"test2\").onclick=test2;//此处不能加括号，加了括号表示调用函数。 /*注意：函数需要通过后面的触发才会调用执行，而上面这句没有放在函数里面，JavaScript从上往下解析的时候，解析到上面的那句代码， 若还没有解析到&lt;body>中的id--test2,就会报错。故JavaScript代码要放在后面。*/ &lt;/script> &lt;/body> &lt;/html>","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://jcuser.github.io/categories/前端学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jcuser.github.io/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"https://jcuser.github.io/tags/前端/"}],"author":"Jcuser"}]}